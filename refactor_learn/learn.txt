
如果你发现自己需要为程序添加一个特性，而代码结构是你无法方便地达成目的，
那就先重构那个程序，使特性的添加比较容易的进行，然后再添加特性。

# 重构的第一步: 建立一组可靠的测试环境

重构就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它，所以方便易用的测试环境特别重要

函数应该放在使用数据的对象内 => Move Method
临时变量如果没有被修改，可以尝试用方法赋值 => Replace Temp with query   # 有争议

一个对象不能在生命周期改变自己的分类，所以尝试使用子类来实现 => ReplaceTyepCodeWithState + MoveMethod + ReplaceConditionalWithPolymorphism


====================第三章 代码的坏味道======================
RULES:
1. 重复代码 => ExtractMethod || PullUpMethod
2. 长得离谱的代码 => 通常有注释的地方就可以变成一个新的函数，然后用函数名来解释 => 有循环的地方 => 有条件表达式 => Extract Method  
3. 过大的类 => 提取类 || 提取子类
4. 过长的参数列表 => 用object代替 || 用函数代替, 某个参数可能直接用函数获取
5. 某个类往不同的方向上发展 => 拆成两个类
6. 一个功能要修改不同的类 => 合成一个类
7. 对别的类的依赖大于对自己类的方法 => 考虑将该方法移到那个类中
8. 一些数据总是聚集出现 => 考虑封装成一个类
9. 建立小的类来管理特定的数据类型
10. swith出现时 => 用多态来优化 =>但不要杀鸡用牛刀
11. 当为某个类增加一个子类，也要为另一个类增加同样子类 => 考虑平行继承
12. 没用的子类, 多余的功能 => 要移除  
13. 只在某个算法中存在的实例变量 => 要单独提炼成一个类
14. 对于消息链(对象1 => 对象2 => 对象3)的处理 => 各个类都提炼出方法
15. 中间件使用过多时，可以去掉中间件
16. 中间件使用过少时，可以放在调用端。还有其他行为，可以变成子类。
17. 两个类交互过多时 => 考虑移动方法和字段
                     => 提炼一个类
                     => 双向数据流变成单项数据流
                     => 用委托替换继承
18. 不完美的库函数 => 用一个新的函数实现想要的逻辑，以后真的实现该功能,也方便替换
                   => 有多个函数要重写时 => 继承
19. 对于纯数据类 => 不应该暴露public 而是用方法来统一管理
20. 对于继承后没有用到所有父类 => 父类再重写一层 
                               => 使用委托
21. 想用注释来解释代码做了什么时 => 考虑重构
22. 注释是用来说明将来打算做什么，以及有哪些不确定的
23. 确保参数的使用正确 => 使用断言


============== 第四章 构建测试体系 ============
1. 编写测试时，先要让它失败，来确保work
2. 编写不完善的测试，好过对完美测试的无限等待 
3. 考虑出错的边界条件, 集中火力来测试
4. 当事情应该出错时，别忘了检查是否抛出异常
5. 不要因为测试无法捕捉所有BUG而不写测试，因为测试可以捕捉到大多数BUG

=============== 第六章 重新组织函数 ===============


