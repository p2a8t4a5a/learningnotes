如果你发现自己需要为程序添加一个特性，而代码结构是你无法方便地达成目的，
那就先重构那个程序，使特性的添加比较容易的进行，然后再添加特性。

# 重构的第一步: 建立一组可靠的测试环境

重构就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它，所以方便易用的测试环境特别重要

函数应该放在使用数据的对象内 => Move Method
临时变量如果没有被修改，可以尝试用方法赋值 => Replace Temp with query   # 有争议

一个对象不能在生命周期改变自己的分类，所以尝试使用子类来实现 => ReplaceTyepCodeWithState + MoveMethod + ReplaceConditionalWithPolymorphism


====================第三章 代码的坏味道======================
RULES:
1. 重复代码 => ExtractMethod || PullUpMethod
2. 长得离谱的代码 => 通常有注释的地方就可以变成一个新的函数，然后用函数名来解释 => 有循环的地方 => 有条件表达式 => Extract Method  
3. 过大的类 => 提取类 || 提取子类
4. 过长的参数列表 => 用object代替 || 用函数代替, 某个参数可能直接用函数获取
5. 某个类往不同的方向上发展 => 拆成两个类
6. 一个功能要修改不同的类 => 合成一个类
7. 对别的类的依赖大于对自己类的方法 => 考虑将该方法移到那个类中
8. 一些数据总是聚集出现 => 考虑封装成一个类
9. 建立小的类来管理特定的数据类型
10. swith出现时 => 用多态来优化 =>但不要杀鸡用牛刀
11. 当为某个类增加一个子类，也要为另一个类增加同样子类 => 考虑平行继承
12. 没用的子类, 多余的功能 => 要移除  
13. 只在某个算法中存在的实例变量 => 要单独提炼成一个类
14. 对于消息链(对象1 => 对象2 => 对象3)的处理 => 各个类都提炼出方法
15. 中间件使用过多时，可以去掉中间件
16. 中间件使用过少时，可以放在调用端。还有其他行为，可以变成子类。
17. 两个类交互过多时 => 考虑移动方法和字段
                     => 提炼一个类
                     => 双向数据流变成单项数据流
                     => 用委托替换继承
18. 不完美的库函数 => 用一个新的函数实现想要的逻辑，以后真的实现该功能,也方便替换
                   => 有多个函数要重写时 => 继承
19. 对于纯数据类 => 不应该暴露public 而是用方法来统一管理
20. 对于继承后没有用到所有父类 => 父类再重写一层 
                               => 使用委托
21. 想用注释来解释代码做了什么时 => 考虑重构
22. 注释是用来说明将来打算做什么，以及有哪些不确定的
23. 确保参数的使用正确 => 使用断言


============== 第四章 构建测试体系 ============
1. 编写测试时，先要让它失败，来确保work
2. 编写不完善的测试，好过对完美测试的无限等待 
3. 考虑出错的边界条件, 集中火力来测试
4. 当事情应该出错时，别忘了检查是否抛出异常
5. 不要因为测试无法捕捉所有BUG而不写测试，因为测试可以捕捉到大多数BUG

=============== 第六章 重新组织函数 ===============
1. ExtractMethod: 提炼的函数名字再长也没关系
                  以这个函数做什么来命名，而不是怎么做
                  局部变量的处理: 1. 用查询来替代
                                  2. 公用的临时变量分开命名
                                  3. 涉及到修改的，返回这个变量
                                  4. 局部变量泛滥成灾，用对象来取代[牛刀]


2.InlineMethod:1. 对于清晰的小函数放回大函数中
               2. 在ReplaceMethodWithMethodObject中特别适用
               3. 使用了太多的间接层时 => 去掉

3.InlineTemp:1. 通常用于ReplaceTempWithQuery
             2. 将只用过一次的临时变量放进去

4.ReplaceTempWithQuery:
             1. 临时变量会驱使你把函数写的很长

5.IntroduceExplainingVariable:
             1.用变量名来解释复杂表达式
             2.用函数通常更好(除非有太多临时变量)

6.SplitTemporaryVariable:
            1.分解临时变量

7.RemoveAssignmentsToParameters:
            1.移除对参数的赋值

8.ReplaceMethodWithMethodObject: 用对象取代函数



=============== 第七章 在对象之间搬移特性 ===============
1.MoveMethod:
    1. 是否与其他类的交互过多? 

2.Move Field
    1. 是否与其他类的交互过多? 

3.Extract Class
    某个类做了应该由两个类做的事情
    1. 不要建立从新类到旧类的链接，要使用单向链接

4.InlineClass
    某个类没有做太多事情
        
5.HideDelegate
    尽可能少的了解系统的其他部分

6.RemoveMiddleMan
    委托过多时

7.IntroduceForeignMethod
    引入外加函数, 来添加功能

8.IntroduceLocalExtension
    引入本地扩展,实现想要的功能
    不在扩展累中复写原函数



==================== 第八章 重新组织数据 ============
1.SelfEncapsulateField
    setField() getField()

2.ReplaceDataValueWithObject
    
3.ChangeValueToReference
    使用工厂函数
    create

4.ChangeReferenveToValue
    将引用对象改为值对象
    值对象有个非常重要的特性，不可变。如果要不改变，只能用一个新的对象。

5.ReplaceArrayWithObject
    数组不是一个好的方式来描述对象

6.DuplicateObserverdData
    对于GUI可以用这个方式来实现分离

7.ChangeUnidirectionalAssociationToBidirectional
    将单向关联改为双向关联
    1. 一对多，由一来维护
    2. 多对多，任意一个维护即可

8.ChangeBidirectionalAssociationToUnidirectional
    将双向关联改为单向关联
    1. 先用赋值的方式来替换


9.ReplaceMagicNumberWithSymbolicConstant    

10.EncapsulateCollection
    封装集合












SepatateQueryFromModifier: 查询和修改函数分离 
                        1. 任何有返回值的函数都不应该有看的到的副作用

