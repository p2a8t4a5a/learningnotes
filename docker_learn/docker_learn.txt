# Docker让应用的部署、测试和分发变得前所未有的高效和轻松

## 基本概念
镜像 --> 只读
   镜像构建时会一层层构建，前一层是后一层的基础,如果在后一层的镜像删除了文件，也只会标记删除，不是真正的删除。
   基础镜像是可以依赖的, 节约硬盘空间
容器 --> 系统
    容器启东时在上面创建一个存储层，存储层的生命周期和容器一样, 任何存储层的东西都会随着容器的删除而消失。
仓库 -->  Docker Registry             
    仓库名经常以两段式路径形式出现: 如 jwilder/nginx-proxy
    Registry公开服务: 官方Docker Hub
    也可搭建自己的私有仓库

## 一键安装docker
curl -fsSL get.docker.com -o get-docker.sh
sudo sh get-docker.sh --mirror Aliyun
    ### 启动docker
        sudo systempctl enable docker
        sudo systempctl start docker
    ### ubuntu 14.04
        sudo service docker start
                                            

# 创建一个新的shell
docker exec -it showdoc /bin/bash # 在已经运行的程序中执行命令
docker exec -d daemon_dave touch /etc/new_config_file
docker run -it ubuntu bash

# 启动镜像
docker start 8ace22b4f825 # 启动老的镜像
docker run 8ace22b4f825 # 运行一个新的镜像

# 建立docker组:
sudo groupadd docker
sudo usermod -aG docekr $USER

# 运行
docker run -it --rm unbuntu bash
#  --rm 容器退出后随即删除 


# 镜像体积
docker images ls 所看到的的体积不是真实的体积，因为使用的是Union FS, 很多层可以共用的

# 虚悬镜像
docker image ls -f dangling=true
docker image prune # 删除虚悬镜像

# 中间层镜像
docker image ls -a

# docker 删除镜像的时候可能删不掉
1. 一个镜像对应多个标签
2. 别的镜像依赖这个镜像
3. 容器对这个镜像有依赖

# commit
    commit是用来理解镜像构成，或者特殊场合，如保存入侵现场，定制镜像用Dockerfile完成
    因为commit以后是一个黑箱操作, 

docker diff webserver 查看改动
docker commit webserver nginx:v2
docker histroy



# install mac
brew install docker docker-compose docker-machine
brew cask install virtualbox

# create machine
docker-machine create --driver virtualbox default
docker-machine start default

# test docker
docker run hello-world

# pull images
docker pull nginx

# docker run
docker run -d -p 80:80 --name webserver nginx




# docker 命令
# cp
docker cp 123.txt bb089aa:/root/
# add 
是cp的升级版本，可以自动下载链接文件, 但还是建议用run wget
某些情况有用，会自动解压压缩文件

# CMD容器启动命令
docker run -it ubuntu # 会自动进入bash
docker run -it ubuntu cat /etc/os-release

shell格式: CMD <命令>
    echo $HOME
    实际会转化成 ["sh", "-c", "echo $HOME"]
exec格式: CMD ["可执行文件", "argv1", "argv2"]
    用"", 因为会解析成json

docker内的应用都应该前台执行


# ENTRYPOINT
用法一:
本质上和CMD是一样的，但是变成添加附加参数
asd = ENTRYPOINT ["echo"]
docker run asd 123

asd = CMD ["echo", "123"]
docker run asd

用法二:
应用前的准备工作
1. 一个预处理脚本
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["redis-server"]

ENV 设置环境变量
ENV key1 value1
ENV key1=value1 key2=value2 \
    key3="111 111"


ARG 构建参数
    ARG和ENV效果一样, 区别是在容器运行时就不存在了

VOLUME定义匿名卷









